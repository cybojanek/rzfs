// SPDX-License-Identifier: GPL-2.0 OR MIT

/*! LZJB compression.
 *
 * LZJB is based on LZRW and LZ77 compression algorithms.
 *
 * ### Byte layout.
 *
 * The byte layout of LZJB compressed data is a sequence of one byte MAP,
 * followed by up to eight blocks. There will fewer than eight blocks if it is
 * the end of the compressed data. Each block is one or two bytes.
 *
 * ```text
 * +-----+-------+-------+-----+-------+-----+-------+-----+
 * | MAP | BLK 0 | BLK 1 | ... | BLK 7 | MAP | BLK 0 | ... |
 * +-----+-------+-------+-----+-------+-----+-------+-----+
 * ```
 *
 * Each bit of MAP, in LSB, indicates how to decode the Nth block after the MAP.
 * If the bit is 0, then BLK is one byte of uncompressed data. If the bit is 1,
 * the block is a two byte big endian encoded [u16], where the most significant
 * 6 bits are a length, and the least significant 10 bits are an offset. To
 * decompress the data, take the current destinaton, subtract offset, and use
 * that as the source of the next length + 3 decompressed bytes.
 *
 * ```text
 *                0
 *  7 6 5 4 3 2 1 0
 * +---------------+
 * |h|g|f|e|d|c|b|a|
 * +---------------+
 *
 * a - 0 or 1 for BLK 0
 * b - 0 or 1 for BLK 1
 * c - ...
 * ```
 *
 * Bit layout of length and offset.
 *
 * ```text
 *            1                   0
 *  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 * +-------------------------------+
 * | length (6)|    offset (10)    |
 * +-------------------------------+
 * ```
 */
use core::cmp;
use core::result::Result;

use crate::compression::{Compression, CompressionError, Decompression, DecompressionError};

////////////////////////////////////////////////////////////////////////////////

/// Number of bits for encoded length.
const LENGTH_BITS: u32 = 6;

/// Number of btis for encoded offset.
const OFFSET_BITS: u32 = 10;

////////////////////////////////////////////////////////////////////////////////

/// Encoded length is the top bits.
const LENGTH_SHIFT: u32 = OFFSET_BITS;

/// Encoded offset uses bottom bits.
const OFFSET_MASK: u16 = (1 << OFFSET_BITS) - 1;

////////////////////////////////////////////////////////////////////////////////

/** The minimum non-encoded length is three, in order to overcome the overhead
 * of using two bytes for length and offset.
 */
const LENGTH_MIN: usize = 3;

/** The maximum length is all six bits, plus the minimum length, because
 * [`LENGTH_MIN`] is subtracted from the length before it is encoded. This comes
 * out to 63 plus 3, which is 66.
 */
const LENGTH_MAX: usize = ((1 << LENGTH_BITS) - 1) + LENGTH_MIN;

////////////////////////////////////////////////////////////////////////////////

/// The value of copy mask, when getting the next copy map.
const COPY_MASK_NEXT: u8 = 0;

/** Length of hash table. Do not change in order to keep compression
 * deterministic, because deduplication happens after compression.
 */
const TABLE_LENGTH: usize = 1024;

////////////////////////////////////////////////////////////////////////////////

/// LZJB compression encoder.
pub struct LzjbEncoder {
    table: [u16; TABLE_LENGTH],
}

impl Default for LzjbEncoder {
    fn default() -> Self {
        Self::new()
    }
}

impl LzjbEncoder {
    /// Create a new LZJB compression encoder.
    pub fn new() -> LzjbEncoder {
        LzjbEncoder {
            table: [0; TABLE_LENGTH],
        }
    }

    /** Compress with LZJB parameters before ZFS version 21.
     *
     * When the deduplication feature was released in ZFS version 21, the
     * parameters for LZJB were altered. This function will compress using the
     * old parameters, and is included for testing LZJB re-compression for older
     * file systems.
     */
    pub fn compress_pre_v21(
        &mut self,
        dst: &mut [u8],
        src: &[u8],
        _level: u32,
    ) -> Result<usize, CompressionError> {
        // NOTE: Refer to [LzjbEncoder::compress] for documentation of common code.
        // NOTE: The table is smaller.
        self.table[0..256].fill(0);

        let mut src_idx: usize = 0;
        let mut dst_idx: usize = 0;

        let mut copy_mask: u8 = COPY_MASK_NEXT;
        let mut copy_map_idx = 0;

        while src_idx < src.len() {
            copy_mask <<= 1;

            if copy_mask == COPY_MASK_NEXT {
                copy_mask = 1;

                if dst.len() - dst_idx < 1 + (u8::BITS * 2) as usize {
                    return Err(CompressionError::NotCompressable {});
                }

                copy_map_idx = dst_idx;
                dst[copy_map_idx] = 0;
                dst_idx += 1;
            }

            if src.len() - src_idx < LENGTH_MAX {
                dst[dst_idx] = src[src_idx];
                dst_idx += 1;
                src_idx += 1;
                continue;
            }

            // NOTE: Hash computation is different, and table is limited to 256.
            let hash: u8 = src[src_idx].wrapping_add(13)
                ^ src[src_idx + 1].wrapping_sub(13)
                ^ src[src_idx + 2];

            let cpy_idx_modulo = &mut self.table[usize::from(hash)];

            let old_offset = (src_idx - (*cpy_idx_modulo as usize)) & usize::from(OFFSET_MASK);
            *cpy_idx_modulo = src_idx as u16;

            let cpy_idx = src_idx - old_offset;

            if cpy_idx != src_idx
                && src[src_idx] == src[cpy_idx]
                && src[src_idx + 1] == src[cpy_idx + 1]
                && src[src_idx + 2] == src[cpy_idx + 2]
            {
                dst[copy_map_idx] |= copy_mask;

                let mut length = LENGTH_MIN;
                while length < LENGTH_MAX {
                    if src[src_idx + length] == src[cpy_idx + length] {
                        length += 1;
                    } else {
                        break;
                    }
                }

                src_idx += length;

                let length_offset = (((length - LENGTH_MIN) << LENGTH_SHIFT) | old_offset) as u16;

                dst[dst_idx..dst_idx + 2].copy_from_slice(&u16::to_be_bytes(length_offset));
                dst_idx += 2;
            } else {
                dst[dst_idx] = src[src_idx];
                dst_idx += 1;
                src_idx += 1;
            }
        }

        Ok(dst_idx)
    }
}

impl Compression for LzjbEncoder {
    fn compress(
        &mut self,
        dst: &mut [u8],
        src: &[u8],
        _level: u32,
    ) -> Result<usize, CompressionError> {
        // Reset the state of the encoder.
        self.table.fill(0);

        // Source and destination indices.
        let mut src_idx: usize = 0;
        let mut dst_idx: usize = 0;

        // Set the copy mask to a value that will cause it to create the
        // copy_map on the first iteration of the loop.
        let mut copy_mask: u8 = COPY_MASK_NEXT;
        let mut copy_map_idx = 0;

        while src_idx < src.len() {
            // Shift copy mask to use next bit.
            copy_mask <<= 1;

            // If no bits are available, get the next copy map index.
            if copy_mask == COPY_MASK_NEXT {
                // Reset the mask to the first bit.
                copy_mask = 1;

                // Check that there is enough space for the map, and for
                // encoding the data for the map, which in the worst case is
                // length and offset (2 bytes) for each bit in the map (8).
                // This might not be the optimal choice, but it simplifies the
                // rest of the code, and conforms to the existing ZFS behavior.
                if dst.len() - dst_idx < 1 + (u8::BITS * 2) as usize {
                    return Err(CompressionError::NotCompressable {});
                }

                // Set the new copy map index.
                copy_map_idx = dst_idx;

                // Set the initial mask to zero.
                dst[copy_map_idx] = 0;

                // Increment destination.
                dst_idx += 1;
            }

            // If there are fewer than LENGTH_MAX bytes remaining, do not try
            // to compress them, just copy them uncompressed.
            if src.len() - src_idx < LENGTH_MAX {
                dst[dst_idx] = src[src_idx];
                dst_idx += 1;
                src_idx += 1;
                continue;
            }

            // Calculate the hash over the next 3 bytes.
            // The access to src is safe, because there must be at least
            // LENGTH_MAX bytes remaining.
            let mut hash = (u32::from(src[src_idx]) << 16)
                | (u32::from(src[src_idx + 1]) << 8)
                | u32::from(src[src_idx + 2]);
            // NOTE: The hash above will be at most 24 bits, and after the
            //       additions below, it will be at most 25 bits.
            hash += hash >> 9;
            hash += hash >> 5;

            // Now look it up in table.
            let cpy_idx_modulo = &mut self.table[(hash as usize) % self.table.len()];

            // The value in the table is index into src, modulo 16 bits.
            // To be more precise, this could be modulus OFFSET_BITS + 1,
            // but casting it down to a [u16] is cheaper.
            //
            // In theory, this could be src_idx, but that would require storing
            // a [usize], requiring either 4k or 8k or memory. Using a [u16],
            // consumes only 2k.
            //
            // As a simplified example, take the following table.
            // The first row is src_idx, the second row is src_idx modulo 65536.
            //
            //  +---+---+---+-----+-------+-------+-------+-------+-----+
            //  | 0 | 1 | 2 | ... | 65535 | 65536 | 65537 | 65538 | ... |
            //  +---+---+---+-----+-------+-------+-------+-------+-----+
            //  | 0 | 1 | 2 | ... | 65535 |     0 |     1 |     2 | ... |
            //  +---+---+---+-----+-------+-------+-------+-------+-----+
            //
            // Within the same modulo block:
            // - take sample src_idx 5
            // - take sample cpy_idx_modulo 2
            // - (5 - 2) % 65536 = 3 is the offset
            //
            // Within the same modulo block:
            // - take sample src_idx 65541
            // - take sample cpy_idx_modulo 2
            // - (65541 - 2) % 65536 = 3 is the offset
            //
            // Across two modulo blocks:
            // - take sample src_idx 65541
            // - take sample cpy_idx_modulo 65535
            // - (65541 - 65535) % 65536 = 6 is the offset
            //
            // Across two modulo blocks.
            // - take sample src_idx 131077
            // - take sample cpy_idx_modulo 65535
            // - (131077 - 65535) % 65536 = 6 is the offset
            //
            // The subtraction is safe, because the value of cpy_idx_modulo must
            // be <= src_idx, since the table starts off filled with zeros, and
            // is filled in by src_idx values below.
            let old_offset = (src_idx - (*cpy_idx_modulo as usize)) & usize::from(OFFSET_MASK);
            *cpy_idx_modulo = src_idx as u16;

            // Compute the copy index.
            let cpy_idx = src_idx - old_offset;

            // If the copy index is not the source itself, and three bytes
            // match, then compress the bytes.
            if cpy_idx != src_idx
                && src[src_idx] == src[cpy_idx]
                && src[src_idx + 1] == src[cpy_idx + 1]
                && src[src_idx + 2] == src[cpy_idx + 2]
            {
                // Set this block as compressed.
                dst[copy_map_idx] |= copy_mask;

                // Start the length.
                let mut length = LENGTH_MIN;
                while length < LENGTH_MAX {
                    // The access to src is safe, because
                    // src.len() - src_idx < LENGTH_MAX is checked above,
                    // and cpy_idx must be less than src_idx.
                    if src[src_idx + length] == src[cpy_idx + length] {
                        length += 1;
                    } else {
                        break;
                    }
                }

                // Advance source index.
                src_idx += length;

                // Subtract minimum length and shift into encoded spot,
                // and or with offset (no shift).
                let length_offset = (((length - LENGTH_MIN) << LENGTH_SHIFT) | old_offset) as u16;

                // Encode to big endian and add to output.
                dst[dst_idx..dst_idx + 2].copy_from_slice(&u16::to_be_bytes(length_offset));
                dst_idx += 2;
            } else {
                // Cannot compress these bytes, so copy the byte, and try with
                // the next ones.
                dst[dst_idx] = src[src_idx];
                dst_idx += 1;
                src_idx += 1;
            }
        }

        Ok(dst_idx)
    }
}

////////////////////////////////////////////////////////////////////////////////

/// LZJB decompression decoder.
pub struct LzjbDecoder {}

impl Decompression for LzjbDecoder {
    fn decompress(
        &mut self,
        dst: &mut [u8],
        src: &[u8],
        _level: u32,
    ) -> Result<(), DecompressionError> {
        // Source and destination indices.
        let mut src_idx: usize = 0;
        let mut dst_idx: usize = 0;

        // Set the copy mask to a value that will cause it to fetch the copy_map on
        // the first iteration of the loop.
        let mut copy_mask: u8 = COPY_MASK_NEXT;
        let mut copy_map: u8 = 0;

        while dst_idx < dst.len() {
            // Shift copy mask to use next bit.
            copy_mask <<= 1;

            // If all 8 bits are used, get the next copy map.
            if copy_mask == COPY_MASK_NEXT {
                // Reset the mask to the first bit.
                copy_mask = 1;

                // Safely get the next copy map.
                copy_map = match src.get(src_idx) {
                    Some(v) => *v,
                    None => {
                        return Err(DecompressionError::EndOfInput {
                            offset: src_idx,
                            capacity: src.len(),
                            count: 1,
                        })
                    }
                };

                // Increment the source.
                src_idx += 1;
            }

            if (copy_map & copy_mask) != 0 {
                // Check if there are two more bytes available from the source.
                if src.len() - src_idx < 2 {
                    return Err(DecompressionError::EndOfInput {
                        offset: src_idx,
                        capacity: src.len(),
                        count: 2,
                    });
                }

                // Decode the next two bytes as a 16 bit big endian number.
                let length_offset =
                    u16::from_be_bytes(src[src_idx..src_idx + 2].try_into().unwrap());

                // Increment the source.
                src_idx += 2;

                // Extract the length and offset.
                let length = usize::from(length_offset >> LENGTH_SHIFT) + LENGTH_MIN;
                let offset = usize::from(length_offset & OFFSET_MASK);

                // Safely compute the copy index.
                let mut cpy_idx = match dst_idx.checked_sub(offset) {
                    Some(v) => v,
                    None => {
                        return Err(DecompressionError::InvalidInput {
                            offset: src_idx - 2,
                        })
                    }
                };

                // Clamp the length to the number of bytes to output.
                let length = cmp::min(length, dst.len() - dst_idx);

                // Copy the bytes one byte at a time.
                // An alternative would be to use:
                // dst.copy_within(cpy_idx..cpy_idx+length, dst_idx);
                // dst_idx += length;
                // However, it is not clear in what order copy_within would copy
                // the bytes. If cpy_idx + length > dst_idx, then it may copy
                // bytes from dst_idx + 1 before copying them from
                // dst_idx + 1 - length.
                for _ in 0..length {
                    dst[dst_idx] = dst[cpy_idx];
                    dst_idx += 1;
                    cpy_idx += 1;
                }
            } else {
                // Copy source to destination.
                dst[dst_idx] = match src.get(src_idx) {
                    Some(v) => *v,
                    None => {
                        return Err(DecompressionError::EndOfInput {
                            offset: src_idx,
                            capacity: src.len(),
                            count: 1,
                        })
                    }
                };

                // Increment source and destination.
                dst_idx += 1;
                src_idx += 1;
            }
        }

        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {

    use crate::compression::{
        Compression, CompressionError, Decompression, DecompressionError, LzjbDecoder, LzjbEncoder,
    };

    // Decompressed data, Compressed Data, Pre-v21 compressed data
    const TEST_VECTORS: &[(&[u8], &[u8], &[u8])] = &[(
        &[
            0x0a, 0x0e, 0x01, 0x03, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xee, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x1f, 0x00, 0x05, 0x00, 0x03, 0x07, 0x0a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x60, 0x45, 0x47, 0xb6, 0x00, 0x00, 0x00,
            0x18, 0x04, 0xcb, 0xaa, 0xf4, 0x3e, 0x01, 0x00, 0x77, 0xd8, 0x1e, 0x8c, 0xdb, 0x9f,
            0x46, 0x01, 0x64, 0x2a, 0x1b, 0xf9, 0x40, 0xed, 0x7f, 0xf5, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x80, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x1f, 0x00, 0x01, 0x00, 0x03, 0x07, 0x0a, 0x80, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xa8, 0x15, 0x7b, 0x54, 0x00,
            0x00, 0x00, 0xe1, 0x6d, 0xda, 0xaa, 0xda, 0x3d, 0x00, 0x00, 0xcb, 0x00, 0x31, 0x6d,
            0xfe, 0xae, 0x17, 0x00, 0xe6, 0x76, 0x59, 0x39, 0xe8, 0x9c, 0x4a, 0x06, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ],
        &[
            0x00, 0x0a, 0x0e, 0x01, 0x03, 0x00, 0x00, 0x00, 0x01, 0xb6, 0x20, 0x00, 0x05, 0x04,
            0x03, 0x01, 0x04, 0x05, 0x04, 0x04, 0x30, 0x04, 0x05, 0x35, 0x7c, 0x04, 0x06, 0x10,
            0x23, 0xf0, 0x10, 0x08, 0x14, 0x10, 0xee, 0xc0, 0x13, 0x0c, 0x11, 0x14, 0x10, 0x98,
            0x80, 0x0c, 0x5a, 0x1f, 0x00, 0x05, 0x60, 0x00, 0x03, 0x07, 0x0a, 0x80, 0x0c, 0x1e,
            0x3c, 0x06, 0x0c, 0x05, 0x10, 0x13, 0x1f, 0x10, 0x08, 0xd2, 0x60, 0x45, 0x47, 0xb6,
            0x01, 0x00, 0x0c, 0x18, 0x04, 0xcb, 0xaa, 0xf4, 0x3e, 0x01, 0x00, 0x00, 0x77, 0xd8,
            0x1e, 0x8c, 0xdb, 0x9f, 0x46, 0x00, 0x01, 0x64, 0x2a, 0x1b, 0xf9, 0x40, 0xed, 0x7f,
            0xec, 0xf5, 0x02, 0x00, 0x1c, 0x04, 0x03, 0x5a, 0x04, 0x05, 0x00, 0x04, 0x18, 0x10,
            0xeb, 0x10, 0x80, 0x14, 0x10, 0x46, 0x18, 0x80, 0x01, 0x68, 0x80, 0x14, 0xb0, 0x0c,
            0xae, 0x80, 0x00, 0x00, 0xfe, 0xa8, 0x15, 0x7b, 0x54, 0x00, 0x58, 0x00, 0xe1, 0x6d,
            0xda, 0xaa, 0xda, 0x3d, 0x00, 0x00, 0x00, 0xcb, 0x00, 0x31, 0x6d, 0xfe, 0xae, 0x17,
            0x00, 0x80, 0xe6, 0x76, 0x59, 0x39, 0xe8, 0x9c, 0x4a, 0x14, 0x2f, 0xff, 0x00, 0x22,
            0xfc, 0x03, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xa4, 0x42, 0x15, 0xa8,
            0x1f, 0xa4, 0x34, 0xfc, 0x2c, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
        &[
            0x00, 0x0a, 0x0e, 0x01, 0x03, 0x00, 0x00, 0x00, 0x01, 0xb6, 0x20, 0x00, 0x05, 0x04,
            0x03, 0x01, 0x04, 0x05, 0x04, 0x04, 0x30, 0x04, 0x05, 0x35, 0x7c, 0x04, 0x06, 0x10,
            0x23, 0xf0, 0x10, 0x08, 0x14, 0x10, 0xee, 0xc0, 0x13, 0x0c, 0x11, 0x14, 0x10, 0x98,
            0x80, 0x0c, 0x5a, 0x1f, 0x00, 0x05, 0x60, 0x00, 0x03, 0x07, 0x0a, 0x80, 0x0c, 0x1e,
            0x3c, 0x06, 0x0c, 0x05, 0x10, 0x13, 0x1f, 0x10, 0x08, 0xd2, 0x60, 0x45, 0x47, 0xb6,
            0x01, 0x00, 0x0c, 0x18, 0x04, 0xcb, 0xaa, 0xf4, 0x3e, 0x01, 0x00, 0x00, 0x77, 0xd8,
            0x1e, 0x8c, 0xdb, 0x9f, 0x46, 0x00, 0x01, 0x64, 0x2a, 0x1b, 0xf9, 0x40, 0xed, 0x7f,
            0xec, 0xf5, 0x02, 0x00, 0x1c, 0x04, 0x03, 0x5a, 0x04, 0x05, 0x00, 0x04, 0x18, 0x10,
            0x4b, 0x10, 0x80, 0x14, 0x10, 0x46, 0x18, 0x80, 0x01, 0x00, 0x64, 0x80, 0x06, 0x0a,
            0x00, 0x0c, 0x01, 0x01, 0x0c, 0x07, 0x00, 0xfe, 0xa8, 0x15, 0x04, 0x7b, 0x54, 0x00,
            0x0c, 0xe1, 0x6d, 0xda, 0xaa, 0xda, 0x00, 0x3d, 0x00, 0x00, 0xcb, 0x00, 0x31, 0x6d,
            0xfe, 0x00, 0xae, 0x17, 0x00, 0xe6, 0x76, 0x59, 0x39, 0xe8, 0xfc, 0x9c, 0x4a, 0x14,
            0x2f, 0x00, 0x22, 0xfc, 0x03, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xff, 0xfc, 0x42,
            0xa4, 0x42, 0x15, 0xa8, 0xa4, 0x34, 0xfc, 0x2c, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    )];

    const TEST_VECTORS_DECOMPRESS_ERRORS: &[(usize, &[u8])] = &[
        // TEST_VECTORS_ZEROS 512, truncated by one byte.
        (
            512,
            &[
                0xfe, 0x00, 0xfc, 0x01, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42,
                0xfc, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00,
            ],
        ),
        // TEST_VECTORS_ZEROS 512, offset is too large in 4th byte.
        (
            512,
            &[
                0xfe, 0x00, 0xfc, 0x02, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42,
                0xfc, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
        ),
    ];

    /** Test vectors that decompress to all zeroes.
     *
     * Each is a tuple of sizes and compressed data. The first size in sizes is
     * the nummber of zeroes. The next size, is the size of the compressed data.
     * The compressed data is the final compressed data.
     */
    const TEST_VECTORS_ZEROS: &[(&[usize], &[u8])] = &[
        (
            &[512],
            &[
                0xfe, 0x00, 0xfc, 0x01, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42,
                0xfc, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
        ),
        (
            &[4096, 137],
            &[
                0x40, 0xfe, 0x00, 0xfc, 0x01, 0xfc, 0x42, 0x1c, 0x02, 0xff, 0x07, 0x1c, 0x0b, 0x0c,
                0x0a, 0xfc, 0x11, 0xfc, 0x42, 0xff, 0xfc, 0x42, 0x00, 0xfc, 0x42, 0xfc, 0x42, 0xfc,
                0x42, 0xfc, 0x42, 0x00, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0x7f, 0xfc, 0x00, 0x42,
                0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0xfc, 0x00, 0x42, 0xfc, 0x42, 0xfc, 0x42, 0x00,
                0x00, 0x00, 0x00, 0x00,
            ],
        ),
        (
            &[1048576, 33799, 1641],
            &[
                0x00, 0x40, 0xfe, 0x00, 0xfc, 0x01, 0xfc, 0x42, 0x1c, 0x00, 0x02, 0xff, 0xe7, 0x1c,
                0x0b, 0x0c, 0x0a, 0xfc, 0x00, 0x11, 0xfc, 0x42, 0xfc, 0x44, 0xfc, 0x44, 0x04, 0x10,
                0xce, 0xff, 0xfc, 0x88, 0x04, 0x02, 0x04, 0x42, 0xfc, 0x80, 0x88, 0x04, 0x46, 0xfd,
                0x10, 0xfc, 0x88, 0x00, 0x11, 0x7b, 0x1c, 0x0d, 0x00, 0x15, 0x42, 0x04, 0x11, 0x08,
                0x1a, 0x04, 0x0d, 0x00, 0x04, 0x46, 0x7e, 0xff, 0x04, 0x27, 0x00, 0x09, 0xfc, 0x33,
                0x10, 0x73, 0x04, 0x4c, 0xfc, 0x66, 0x04, 0xf7, 0xfc, 0x99, 0xfc, 0xff, 0x01, 0x4d,
                0x04, 0xfd, 0x32, 0x01, 0x18, 0xfd, 0x65, 0xfd, 0xcb, 0xff, 0xfd, 0x98, 0x0e, 0x4a,
                0xfc, 0xcc, 0xfc, 0xcc, 0xfc, 0xcc, 0xfc, 0xcc, 0x00, 0x84, 0x0b, 0x49, 0xff, 0x06,
                0xec, 0x1b, 0x3d, 0x00, 0x15, 0xfe, 0x31, 0xfe, 0x31, 0xfc, 0x99, 0x03, 0x3d, 0xfc,
                0xcc, 0xef, 0xfd, 0x65, 0x00, 0x84, 0xfc, 0xcc, 0xfc, 0xcc, 0x88, 0x00, 0x88, 0x09,
                0xe4, 0xfe, 0xfd, 0xbf, 0xfe, 0xfd, 0x04, 0x8c, 0x06, 0x75, 0x09, 0x19, 0x04, 0x0d,
                0x00, 0x04, 0x46, 0x7c, 0x99, 0x00, 0x07, 0xfc, 0x88, 0x04, 0x46, 0xfd, 0x10, 0xfc,
                0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
        ),
    ];

    #[test]
    fn compress() -> Result<(), CompressionError> {
        let mut lzjb = LzjbEncoder::new();

        // Loop over test vectors.
        for (decompressed_data, compressed_data, compressed_data_pre_v21) in TEST_VECTORS {
            // Create output.
            let mut output = vec![0; decompressed_data.len()];

            // Compress the data.
            let ret = lzjb.compress(&mut output, decompressed_data, 0)?;

            // Check result.
            assert!(ret <= compressed_data.len());
            assert_eq!(&output[0..compressed_data.len()], *compressed_data);

            // Now test the old compression.
            output.fill(0);
            let ret = lzjb.compress_pre_v21(&mut output, decompressed_data, 0)?;
            assert!(ret <= compressed_data_pre_v21.len());
            assert_eq!(
                &output[0..compressed_data_pre_v21.len()],
                *compressed_data_pre_v21
            );
        }

        Ok(())
    }

    #[test]
    fn decompress() -> Result<(), DecompressionError> {
        let mut lzjb = LzjbDecoder {};

        // Loop over test vectors.
        for (decompressed_data, compressed_data, compressed_data_pre_v21) in TEST_VECTORS {
            // Create output.
            let mut output = vec![0; decompressed_data.len()];

            // Decompress the data.
            lzjb.decompress(&mut output, compressed_data, 0)?;

            // Check result.
            assert_eq!(output, *decompressed_data);

            // Now test the old compression.
            output.fill(0);
            lzjb.decompress(&mut output, compressed_data_pre_v21, 0)?;
            assert_eq!(output, *decompressed_data);
        }

        Ok(())
    }

    #[test]
    fn compress_error() -> Result<(), CompressionError> {
        let mut lzjb = LzjbEncoder::new();

        // Loop over test vectors.
        for (decompressed_data, _compressed_data, _compressed_data_pre_v21) in TEST_VECTORS {
            // Create output.
            let mut output = vec![0; decompressed_data.len()];

            // Compress the data.
            let ret = lzjb.compress(&mut output, decompressed_data, 0)?;

            // Provide an output that is too small.
            assert!(lzjb
                .compress(&mut output[0..ret - 1], decompressed_data, 0)
                .is_err());

            // Now test the old compression.
            let ret = lzjb.compress_pre_v21(&mut output, decompressed_data, 0)?;

            // Provide an output that is too small.
            assert!(lzjb
                .compress_pre_v21(&mut output[0..ret - 1], decompressed_data, 0)
                .is_err());
        }

        Ok(())
    }

    #[test]
    fn decompress_error() {
        let mut lzjb = LzjbDecoder {};

        // Loop over test vectors.
        for (size, compressed_data) in TEST_VECTORS_DECOMPRESS_ERRORS {
            // Create output that is too large.
            let mut output = vec![0; *size];

            // Decompress the data.
            for test_size in 0..compressed_data.len() {
                assert!(lzjb
                    .decompress(&mut output, &compressed_data[0..test_size], 0)
                    .is_err());
            }
        }
    }

    #[test]
    fn compress_zeros() -> Result<(), CompressionError> {
        let mut lzjb = LzjbEncoder::new();

        // Loop over test vectors.
        for (sizes, compressed_data) in TEST_VECTORS_ZEROS {
            // Set decompressed data as input.
            let mut input = vec![0; sizes[0]];

            // Compress the chain.
            for size in sizes.iter() {
                // Check size.
                assert_eq!(input.len(), *size);

                // Output is the same size as input.
                let mut output = vec![0; input.len()];
                let ret = lzjb.compress(&mut output, &input, 0)?;

                // Set as input to next step.
                input = output[0..ret].to_vec();
            }

            // Check final result.
            assert_eq!(input.len(), compressed_data.len());
            assert_eq!(&input, compressed_data);
        }

        Ok(())
    }

    #[test]
    fn decompress_zeros() -> Result<(), DecompressionError> {
        let mut lzjb = LzjbDecoder {};

        // Loop over test vectors.
        for (sizes, compressed_data) in TEST_VECTORS_ZEROS {
            // Set compressed data as input.
            let mut input = compressed_data.to_vec();

            // Decompress the chain.
            // Iterate in reverse, because the sizes are large to small.
            for size in sizes.iter().rev() {
                // Set the initial values to non-zero to check that data is
                // actually written out.
                let mut output = vec![33; *size];
                lzjb.decompress(&mut output, &input, 0)?;

                // Set as input to next step.
                input = output;
            }

            // Should be all zeroes.
            assert!(input.iter().all(|&b| b == 0));
        }

        Ok(())
    }
}
